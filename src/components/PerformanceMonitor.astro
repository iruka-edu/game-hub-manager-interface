---
// Performance monitoring component for development/testing
const isDev = import.meta.env.DEV;
---

{isDev && (
  <div id="perf-monitor" class="fixed bottom-4 right-4 bg-black/80 text-white text-xs p-3 rounded-lg font-mono z-50 max-w-xs">
    <div class="flex items-center justify-between mb-2">
      <span class="font-semibold">Performance Monitor</span>
      <button id="perf-toggle" class="text-gray-300 hover:text-white">×</button>
    </div>
    <div id="perf-metrics" class="space-y-1">
      <div>Loading...</div>
    </div>
  </div>
)}

<script>
  if (import.meta.env.DEV) {
    class PerformanceMonitor {
      private metrics: any = {};
      private observer: PerformanceObserver | null = null;
      
      constructor() {
        this.init();
      }
      
      init() {
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => this.startMonitoring());
        } else {
          this.startMonitoring();
        }
      }
      
      startMonitoring() {
        this.setupPerformanceObserver();
        this.measureNetworkTiming();
        this.detectDevice();
        this.startRealTimeUpdates();
        this.setupToggle();
      }
      
      setupPerformanceObserver() {
        if ('PerformanceObserver' in window) {
          this.observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.entryType === 'largest-contentful-paint') {
                this.metrics.lcp = Math.round(entry.startTime);
              }
              if (entry.entryType === 'first-input') {
                this.metrics.fid = Math.round(entry.processingStart - entry.startTime);
              }
            }
            this.updateDisplay();
          });
          
          try {
            this.observer.observe({ entryTypes: ['largest-contentful-paint', 'first-input'] });
          } catch (e) {
            console.warn('Performance Observer not fully supported');
          }
        }
      }
      
      measureNetworkTiming() {
        if ('performance' in window && 'timing' in performance) {
          const timing = performance.timing;
          this.metrics.ttfb = timing.responseStart - timing.requestStart;
          this.metrics.domLoad = timing.domContentLoadedEventEnd - timing.navigationStart;
          this.metrics.fullLoad = timing.loadEventEnd - timing.navigationStart;
        }
        
        // Measure resource loading
        if ('performance' in window && 'getEntriesByType' in performance) {
          const resources = performance.getEntriesByType('resource');
          let totalSize = 0;
          let slowestResource = { name: '', duration: 0 };
          
          resources.forEach((resource: any) => {
            if (resource.transferSize) {
              totalSize += resource.transferSize;
            }
            if (resource.duration > slowestResource.duration) {
              slowestResource = {
                name: resource.name.split('/').pop() || resource.name,
                duration: Math.round(resource.duration)
              };
            }
          });
          
          this.metrics.totalSize = Math.round(totalSize / 1024); // KB
          this.metrics.resourceCount = resources.length;
          this.metrics.slowestResource = slowestResource;
        }
      }
      
      detectDevice() {
        const ua = navigator.userAgent;
        let device = 'Unknown';
        let browser = 'Unknown';
        
        // Device detection
        if (/iPhone|iPad|iPod/.test(ua)) {
          device = ua.includes('iPad') ? 'iPad' : 'iPhone';
        } else if (/Android/.test(ua)) {
          device = ua.includes('Mobile') ? 'Android Phone' : 'Android Tablet';
        } else if (/Windows/.test(ua)) {
          device = 'Windows PC';
        } else if (/Mac/.test(ua)) {
          device = 'Mac';
        }
        
        // Browser detection
        if (ua.includes('Chrome') && !ua.includes('Edge')) {
          browser = 'Chrome';
        } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
          browser = 'Safari';
        } else if (ua.includes('Edge')) {
          browser = 'Edge';
        } else if (ua.includes('Firefox')) {
          browser = 'Firefox';
        }
        
        this.metrics.device = device;
        this.metrics.browser = browser;
        this.metrics.screen = `${screen.width}×${screen.height}`;
        this.metrics.viewport = `${window.innerWidth}×${window.innerHeight}`;
      }
      
      startRealTimeUpdates() {
        // Update memory usage if available
        setInterval(() => {
          if ('memory' in performance) {
            const memory = (performance as any).memory;
            this.metrics.memory = Math.round(memory.usedJSHeapSize / 1024 / 1024); // MB
          }
          this.updateDisplay();
        }, 2000);
      }
      
      setupToggle() {
        const toggle = document.getElementById('perf-toggle');
        const monitor = document.getElementById('perf-monitor');
        
        toggle?.addEventListener('click', () => {
          if (monitor) {
            monitor.style.display = monitor.style.display === 'none' ? 'block' : 'none';
          }
        });
      }
      
      updateDisplay() {
        const container = document.getElementById('perf-metrics');
        if (!container) return;
        
        const html = `
          <div><strong>Device:</strong> ${this.metrics.device || 'Unknown'}</div>
          <div><strong>Browser:</strong> ${this.metrics.browser || 'Unknown'}</div>
          <div><strong>Screen:</strong> ${this.metrics.screen || 'Unknown'}</div>
          <div><strong>Viewport:</strong> ${this.metrics.viewport || 'Unknown'}</div>
          <div class="border-t border-gray-600 pt-1 mt-1">
            <div><strong>TTFB:</strong> ${this.metrics.ttfb || 'N/A'}ms</div>
            <div><strong>LCP:</strong> ${this.metrics.lcp || 'N/A'}ms</div>
            <div><strong>DOM Load:</strong> ${this.metrics.domLoad || 'N/A'}ms</div>
            <div><strong>Full Load:</strong> ${this.metrics.fullLoad || 'N/A'}ms</div>
          </div>
          <div class="border-t border-gray-600 pt-1 mt-1">
            <div><strong>Resources:</strong> ${this.metrics.resourceCount || 0}</div>
            <div><strong>Total Size:</strong> ${this.metrics.totalSize || 0}KB</div>
            ${this.metrics.slowestResource ? `<div><strong>Slowest:</strong> ${this.metrics.slowestResource.name} (${this.metrics.slowestResource.duration}ms)</div>` : ''}
            ${this.metrics.memory ? `<div><strong>Memory:</strong> ${this.metrics.memory}MB</div>` : ''}
          </div>
        `;
        
        container.innerHTML = html;
      }
      
      // Export data for testing reports
      exportData() {
        return {
          timestamp: new Date().toISOString(),
          url: window.location.href,
          ...this.metrics
        };
      }
    }
    
    // Initialize performance monitor
    const perfMonitor = new PerformanceMonitor();
    
    // Make it globally available for testing
    (window as any).perfMonitor = perfMonitor;
    
    // Log performance data to console for easy copying
    setTimeout(() => {
      console.log('Performance Data:', perfMonitor.exportData());
    }, 3000);
  }
</script>

<style>
  #perf-monitor {
    font-size: 11px;
    line-height: 1.3;
    backdrop-filter: blur(4px);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
</style>